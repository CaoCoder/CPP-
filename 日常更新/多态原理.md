多态原理

#  final

##   修饰父类函数

父类虚函数加上了final，子类虚函数就不能被重写。

##  修饰类不能被继承

如果加在了类的后面则不能被继承，class car final

#  override辅助是否完成了重写

在函数后面加上override就可以检查是否完成了重写。

#  抽象类

![image-20230813113001653](E:\markdown\图片\image-20230813113001653.png)

1.子类必须进行重写。

  

#  实现继承和接口继承

普通函数的继承是实现继承，继承的是函数的实现，继承下来可以直接用。

虚函数的继承是接口继承，继承的是函数的声明，也就是接口，继承下来的目的是为了重写，达成多态。 

#  多态的原理

虚函数表，虚函数要进入虚表。子类和父类各一份，子类拷贝一份父类的。加入子类重写了父类虚函数，那么子类虚表函数地址就会覆盖父类的。

##  多继承的虚表

以下是子类d的虚表。不是从父类继承下来的虚函数，会在base1这个虚表里。

![image-20230813154935656](E:\markdown\图片\image-20230813154935656.png)

![image-20230813161430029](E:\markdown\图片\image-20230813161430029.png)

因为Derive d; Base1* ptr1 = &d; Base2 * ptr2 = &d; ptr1->fun1();ptr2->func2();

在虚表中，ptr1确实确实指向的是Derive的func1(),但是ptr2指向的是Base2的func1()所以底层会自动调整位置。使他指向Derive的func1();

![image-20230813153240971](E:\markdown\图片\image-20230813153240971.png)

指针的地址的值不一样。



  #  注意点

不要把虚函数表和虚基表搞混了。

虚函数表存的是虚函数的地址。虚基表存的是偏移量，为了解决菱形继承的问题。
c++11可变参数模板（了解）

参数包可以是0个或几个。

```C++
#include <iostream>
using namespace std;

//Args是模板参数包，args是一个函数形参的参数包
template <class ...Args>
void ShowList1(Args... args)
{
    cout << sizeof...(args)<< endl;//可以拿到参数的个数
    
}

int main()
{
    ShowList1(1,2,3);
    return 0;
}
```

逗号表达式，是[c语言](https://baike.baidu.com/item/c语言/105958?fromModule=lemma_inlink)中的[逗号运算符](https://baike.baidu.com/item/逗号运算符/7959271?fromModule=lemma_inlink)，优先级别最低，它将两个及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的值为最后一个[表达式](https://baike.baidu.com/item/表达式/7655228?fromModule=lemma_inlink)的值。

![image-20230815111727522](E:\markdown\图片\image-20230815111727522.png)

##  emplace_back

emlace可以直接构造

![image-20230815113135360](E:\markdown\图片\image-20230815113135360.png)

#  lambda表达式

用仿函数实现单个排序很简单，但是对于排序各种类型，还需要改变仿函数，这导致很麻烦，解决这个问题的出现，就有了lambda表达式。

一般labmda都定义在局部。注意这是表达式，所以要加分号 ； 。

**lambda表达式**实际是一个**匿名函数**

lambda表达式的格式：
![image-20230815122508419](E:\markdown\图片\image-20230815122508419.png)

```C++
int main()
{
    int a = 1;
    int b = 2;
    //捕捉列表 参数 返回值 函数体
    auto Add1 = [](int x, int y)->int{return x + y;};
     //捕捉列表 参数 函数体
     
    auto Add2 = [](int x, int y){return x + y;};
    
    cout << Add1(a, b) << endl;
    cout << Add2(a, b) << endl;

}
```

一般都是[ ] ( ) {} 这三部分组成。

一般都是方括号，圆括号，花括号，构成了lambda表达式。

##  捕捉列表

lambda最大的特点就是捕捉列表。

捕捉列表进行捕捉了参数后，参数列表就可以省略，这时候就可以写为[ ] { }。

  

```C++
int main()
{
    int a = 1;
    int b = 2;

     
    auto Add2 = [a,b]{return a + b;};
    
    cout << Add2(a, b) << endl;

}
```



###  传值全部捕捉，传引用全部捕捉

![image-20230815131248704](E:\markdown\图片\image-20230815131248704.png)

###  混着捕捉

![image-20230815131407324](E:\markdown\图片\image-20230815131407324.png)

###  传引用+传值捕捉

![image-20230815131634840](E:\markdown\图片\image-20230815131634840.png)

**应用场景：假如不想传参了，就用lambda表达式，这样可以省去捕捉**

![image-20230815132150342](E:\markdown\图片\image-20230815132150342.png)

##  mutable

可以使原本lambda的const属性去掉。



#  lambda原理和注意点

1.底层其实是转化成了仿函数，

2。lambda相互之间不能赋值



#  function包装器

本质上是一个类模板。使用时需要加上头文件<functional>

搞网络编程的时候用的会多。因为现在可调用的类型很多。

比如函数指针，仿函数，lambda对象，等等。

 应用场景举例：适合**命令和操作(函数)对应**的场景。 

![image-20230815170721416](E:\markdown\图片\image-20230815170721416.png)

```C++
template<class F, class T>
T useF(F f, T x)
{
    static int count = 0;
    cout << "count:" << ++count << endl;
    cout << "count:" << &count << endl;
    return f(x);
}
double f(double i)
{
    return i / 2;
}
struct Functor
{
    double operator()(double d)
    {
    return d / 3;
    }
};
int main()
{

    //使用包装器，统一了函数类型。这样都是同一份模板。
    function<double(double)> func1 = f;
    cout << useF(func1, 11.12)<<endl;
    function<double(double)> func2 = Functor();
    cout << useF(func2, 11.12)<<endl;


    // 函数名
    cout << useF(f, 11.11) << endl;
    // 函数对象
    cout << useF(Functor(), 11.11) << endl;
    // lamber表达式
    cout << useF([](double d)->double{ return d/4; }, 11.11) << endl;
    return 0;
}
```

#  bind绑定(了解一下)

![image-20230815174232666](E:\markdown\图片\image-20230815174232666.png)

对于多个参数的情况，穿不过去，多了一个参数，比如这个隐藏的参数this指针。

以下是三个参数调整成传两个参数的方法

![image-20230815193145892](E:\markdown\图片\image-20230815193145892.png)

还可以调整顺序，但是一般用处不大。


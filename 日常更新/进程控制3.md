

#  进程控制

##  fork之后父子共享代码

fork之后父子共享所有代码。

![image-20230917222109562](E:\markdown\图片\image-20230917222109562.png)

但是子进程只能从fork()之后开始执行。

##  fork之后OS做了什么

![image-20230917222327388](E:\markdown\图片\image-20230917222327388.png)

##  写时拷贝

父子代码共享，数据也共享，指的是再不写入的情况下共享。

![image-20230917222653461](E:\markdown\图片\image-20230917222653461.png)

红色代表共享的代码段。

蓝色代表数据段进行写时拷贝后的结果，数据段不共享了。因为进行了写时拷贝。

##  为什么要进行写时拷贝？

1.父进程的数据，子进程不一定全用。

2.可以，但是万一不需要修改数据的话就会浪费空间。

**本质上一中延迟拷贝的策略，延迟拷贝的最大价值是只有真正使用的时候才给你空间。**

意味着也可以先给别人。

![image-20230917223524830](E:\markdown\图片\image-20230917223524830.png)

 

##  进程终止

![image-20230917224651124](E:\markdown\图片\image-20230917224651124.png)

###  echo $?可以显示最近一次执行完毕时对应进程的退出码

##  把错误码转化为错误信息

不同的数字对应不同的原因。这只是C语言定义的，你也可以自定义来对应错误原因来定位问题。

##  进程终止常见做法

1.C语言库函数exit,在人以为只会自动刷新缓冲区

2.系统调用函数_exit，直接终止进程，不会有任何刷新操作

3.ctrl+c

![image-20230917225312609](E:\markdown\图片\image-20230917225312609.png)

##  关于进程终止，内核做了什么

![image-20230917225720620](E:\markdown\图片\image-20230917225720620.png)

#  进程等待

1.**等待僵尸进程Z状态，进入S状态，防止内存泄漏**

2.获取子进程的退出状态，看子进程是否是正常退出

3.回收子进程资源，获取子进程退出信息

##  wait系统接口

等待任意一个退出的子进程

![image-20230917230113516](E:\markdown\图片\image-20230917230113516.png)

##  waipid

实际使用最多的接口。

![image-20230917230936984](E:\markdown\图片\image-20230917230936984.png)

返回的pid == 0说明等待成功了，但是子进程没有退出。

options默认是 0 , 0 代表阻塞等待。

子进程退出的时候，会将退出信息写入task_struct中。

status会从子进程的pcb中拿出子进程的退出码。

因为status是一个输出型参数。主要是为了从操作系统拿数据。

##  status

通过status的次低八位可以得到子进程的退出码。

这里所谓的退出码就是exit(104)中的104 值。



![image-20230917231606202](E:\markdown\图片\image-20230917231606202.png)

status的低八位代表异常退出。

也就是退出信号。

接到信号异常退出后，退出码的结果已经不重要了。

一旦进程出现异常，只关心退出信号，此时的退出码已经毫无意义了。



##  WIFEXITED可以查看是否正常退出

![image-20230917232601971](E:\markdown\图片\image-20230917232601971.png)

##  非阻塞等待

![image-20230918204720259](E:\markdown\图片\image-20230918204720259.png)

![image-20230918205232897](E:\markdown\图片\image-20230918205232897.png)

多次调用非阻塞接口的方法叫做-----轮询检测

waitpid返回的pid == 0说明等待成功了，但是子进程没有退出。父进程继续做其他的事情。


#  C++是如何支持函数重载的?

函数重载就是 形参个数，类型，和类型顺序(比如int , double和double， int)不同。

和返回值没有关系，因为调用的时候传参数无法区分要调用谁。



##  为什么C语言不支持重载，C++支持重载。

C++是如何支持的？

编译链接的过程：

f.h f.cpp test.cpp

1.预处理

头文件展开，宏替换，条件编译，去掉注释

.h就在.cpp文件中展开了。生成f.i  test.i文件

2.编译

检查语法，生成汇编代码（指令代码）。由语法错误就在这里出现的。比如缺省参数，为什么只能在声明给，因为在声明给的话，.h会在.cpp展开，这时候会检查**调用和声明是否一致**，所以在声明没给的时候，编译器会报错，因为可能调用没给参数，声明也没给。

生成f.s test.s

3.汇编

因为cpu机器不认识汇编，把汇编代码需要在翻译为二进制的机器码，生成目标文件

f.o test.o



4.链接

做一件重要的事情，找调用函数的地址，链接对应上，合并到一起。 

f.o里面因为头文件展开，所以有函数的声明和定义。

test.o里面是函数的声明和调用。

但是调用的时候，需要找到函数的地址，所以在这个链接的阶段从符号表中找函数的地址。

可以用objdump -S tc 指令查看函数地址

可以看到用gcc编译器生成的函数地址就是函数名，而g++生成的是 **_Z+函数名长度+函数名+形参首字母**

##  extern “C”

这个是C++里面的语法，不是C里的语法

改变链接方式，可以帮助我们实现C调C++的静态库,和C++调C静态库。

现在有一个C++x项目，想用C的静态库怎么用呢？


包含头文件。需要用相对路径找到静态库.h所在的文件位置。

  

然后用extern “c”来包含头文件。告诉C++编译器要用C的规则来找函数地址。因为函数重载规则不一样。



##   那么C怎么调用C++的静态库。

因为extern “C”是C++的语法，所以还是需要改变C++的文件，所以还是需要用extern "C"来包含C++的函数声明，但是头文件替换展开的时候，因为C语法不认识extern "C“,所以还是报链接错误，这时候就要用到条件编译。

![image-20230802132229375](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230802132229375.png)

条件编译在跨平台的地方非常有用，处理的核心地方都在C++文件里面。

假如C调C++的库，C++就不能写函数重载了。到时候编译就编译不过了。





##  引用必须在定义的时候初始化

引用一旦引用了一个实体，就不能再改变了。

对常量取别名，const int& c = 20;需要加上const

double d = 2.2;

const int& e= d;属于隐士类型转换，d赋值给e的时候会先交给临时变量，临时变量具有常性。常性不能被修改。

这时候e就不是d的别名了。是临时变量的别名。这时候取e的地址和取d的地址不一样。



到模板后尽量用引用传参，减少拷贝，然后加上const就能传各种类型。所以才会有形参(const T& x)

**静态变量记住一句话：静态变量只会初始化一次，只会执行一次初始化的代码**

****



如何函数返回时，出了函数作用域，如果对象还在，没有还给系统，就可以用引用返回，如果已经返回给系统了，就会产生越界。

   

宏的代码 ：#define ADD(x,y) ((x)+(y)) 宏就是替换。拿调用的地方试试，就知道自己写的宏到底对不对。

inline自动展开，debug情况下支持调试，不容易写错。

#  类和对象

auto可以自动获得类型，也可以指定类型。比如用auto*, auto&。

typeid(a).name()可以获取变量的类型。

##  结构体内存对齐，对象大小的计算。

没有成员变量的类，空类的大小是1，表示对象存在过。 

![image-20230802211835202](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230802211835202.png)


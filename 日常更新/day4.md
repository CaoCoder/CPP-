day4

内联函数，不支持声明和定义分离。

所以成员函数中要成为inline要放在类里面定义。类里面定义的默认就是inline函数。



闰年判断方法。四年一闰，百年不润，或者四百年润一次。

```
if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
```

拷贝构造写的时候一般都加上const 引用。 const是权限比较小的。传入临时变量，常量都没有问题。

假如不加const，会发生权限放大。

一般日期类就是+服用+=，因为+=用的是引用返回。

判读是否用引用返回，判断原则就是，看对象出了作用域是否销毁。*this出了作用域不会销毁。

正因为 `this` 指针是在函数调用时传递的，而不是在函数内部声明的局部变量，所以它的生命周期与函数调用期间一致。这也是为什么 `this` 指针不会在函数作用域结束时被销毁，而是在整个函数调用过程中保持有效。



##  重载++

C++语法规定，后置++多增加了一个int参数进行占位。

但是不能给缺省参数。因为加参数就是为了区分前置和后置。你给了一个缺省的，根本区分不来。

 ##   加const的函数 

建议成员函数中不修改成员变量的函数都加上const。

##  流提取运算符的重载

因为对于内置类型是支持直接输出输入的。但对于自定义类型不行，所以需要进行重载运算符。

##  友元函数

友元可以加在任意位置，友元只要在**他想访问的类里面的**前面给函数加个声明就行了。并在函数声明前加上friend，这样这个朋友就可以访问私有成员变量。(例如想访问日期类里面的私有变量，就在类里面声明这个函数是他的朋友)

friend void operator<<(std::ostream& out, const Date& d);

![image-20230805202427291](E:\markdown\图片\image-20230805202427291.png)

全局函数不能在.h中定义，因为会在其他两个.cpp文件中都展开，这样两个符号表都有函数的地址，所以才会导致冲突。

为什么类里面的函数也在.h中，但是却可以呢？因为类里面的成员函数默认是inline，会自动在.cpp中展开。

##  初始化列表

初始化列表的产生是为了某些变量。

初始化列表可以认为就是对象成员定义的地方。

因为对于**const int _n, int& ref** ,(**还有自定义类型的类，但该类没有默认构造函数**)这些类型的变量。只能定义的时候初始化，后面不可以赋值和修改。

![image-20230805205645151](E:\markdown\图片\image-20230805205645151.png)

每个成员变量在初始化列表只能初始化一次。

以后变量初始化，尽量都在初始化列表初始化。

有了拷贝构造后，编译器就不会生成默认的构造函数。

##  explicit防止隐士类型的转换

单参数的构造函数支持隐士类型的转换。

##  static

静态变量属于整个类，不只是属于某个对象。

![image-20230805214107084](E:\markdown\图片\image-20230805214107084.png)

静态变量是在类里面声明，在类外进行定义和初始化。需要指定类域。

##  静态的成员函数也没有this指针。

 静态成员函数内，不能访问非静态成员变量，因为没有this指针，。      
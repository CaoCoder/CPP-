#  进程阻塞

一个进程如果申请资源，比如cpu资源，或者慢设备资源，比如磁盘，都是需要**排队**的。这时候会有一个队列叫做**运行队列**。

也就是task_struct会进行排队。 

**比如：假如一个进程在cpu中正在运行，现在需要从磁盘中读取数据，但是磁盘这个设备正在给其他进程提供服务。**

**1.当前进程要从cpu的运行队列移除**

**2.将当前进程放入对应设备的磁盘的描述结构体的等待队列中。**

![image-20230901160238567](E:\markdown\图片\image-20230901160238567.png)

每个设备都会有一个队列。

![image-20230901160441604](E:\markdown\图片\image-20230901160441604.png)

当某个设备就绪了，这时候他就会告诉操作系统。然后将pcb放到运行队列中让cpu调度。

这就叫做进程阻塞。进程阻塞是一种临时状态。

**所谓的从阻塞状态到运行状态就是将进程的pcb从等待队列放入运行队列。**

#  进程挂起

假如**内存不足**了。

操作系统就要帮我们辗转腾挪。

这时候操作系统会把短期内不会被调度的进程。(短期内不会就绪的进程)，把该**进程的代码和数据置换**到**磁盘**上。因为它的代码和数据依旧在内存中，白白的浪费了空间。

这就叫做进程挂起。

![image-20230901162143417](E:\markdown\图片\image-20230901162143417.png)

#  Linux进程状态

##  D状态(深度睡眠状态)

等待磁盘就绪

![image-20230901165505734](E:\markdown\图片\image-20230901165505734.png)

##  僵尸状态Z

当一个进程退出的时候，一般不会直接进入X(死亡状态,资源立马回收的状态)，而是进入了Z状态。

当子进程退出的时候，一般需要将进程的执行结果告知给父进程OS。

进程退出的信息需要父进程来读取，通过进程等待函数来读取。

 

![image-20230901180236770](E:\markdown\图片\image-20230901180236770.png)

![image-20230901180437447](E:\markdown\图片\image-20230901180437447.png)

##  孤儿进程

![image-20230901181108163](E:\markdown\图片\image-20230901181108163.png)

##  前台进程和后台进程

S+是前台进程

S是后台进程

后台进程用ctrl+c杀不掉。

##   独立性

多进程运行，需要独享各种资源，多进程运行期间互相不干扰。



 ##  并行

![image-20230901191448134](E:\markdown\图片\image-20230901191448134.png)

##  并发

 我们的大部分操作系统都是分时操作系统。

![image-20230901192108729](E:\markdown\图片\image-20230901192108729.png)

##  进程抢占

![image-20230901192835947](E:\markdown\图片\image-20230901192835947.png)

#  进程上下文

![image-20230901194946664](E:\markdown\图片\image-20230901194946664.png)
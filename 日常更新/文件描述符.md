##  文件描述符

##   内建命令

想要有父进程执行这个命令，而不是子进程执行这个命令。



![image-20230920175317062](E:\markdown\图片\image-20230920175317062.png)

![image-20230921090222291](E:\markdown\图片\image-20230921090222291.png)

##  文件概念

![image-20230921091536456](E:\markdown\图片\image-20230921091536456.png)



![image-20230921094313867](E:\markdown\图片\image-20230921094313867.png)

![image-20230921094728178](E:\markdown\图片\image-20230921094728178.png)

##  open系统接口

![image-20230921110622713](E:\markdown\图片\image-20230921110622713.png)

![image-20230921104732568](E:\markdown\图片\image-20230921104732568.png)

对于文件：

- 实际权限 = 默认权限 & ~umask

所以八进制的0666需要和默认权限掩码002的反码进行按位与。得到实际权限是0664。

如果想让权限就是实际权限，则需要将umask设为0。

![image-20230921105915579](E:\markdown\图片\image-20230921105915579.png)

O_CREAT:文件不存在就创建

O_TRUNC:文件截断清空。

##  read系统接口

 

![image-20230921110419025](E:\markdown\图片\image-20230921110419025.png)

##  文件描述符

![image-20230921110808535](E:\markdown\图片\image-20230921110808535.png)

![image-20230921111124776](E:\markdown\图片\image-20230921111124776.png)

这就是C语言里结构体的fd。

##  为什么fd是0,1,2,3,4....

![image-20230921111705731](E:\markdown\图片\image-20230921111705731.png)

对进程被打开文件的管理，转化成为了对链表的增删查改。

![image-20230921112116026](E:\markdown\图片\image-20230921112116026.png)

这就是fd是0,1，2,3的来源。

##  如何理解Linux一切皆文件

###  C语言如何模拟实现面向对象？

可以在结构体用函数指针来实现。

![image-20230921112559414](E:\markdown\图片\image-20230921112559414.png)

下面叫做VFS虚拟文件系统

![image-20230921113311534](E:\markdown\图片\image-20230921113311534.png)

上层用的是同一个方法，下层是不同的硬件设备，这就是多态。



![image-20230921113356851](E:\markdown\图片\image-20230921113356851.png)

如何证明上面说的是对的？
查看Linux内核源代码，就会发现有这些结构体的代码。

##  文件描述符的分配规则

![image-20230921114600489](E:\markdown\图片\image-20230921114600489.png)

从头遍历数组，找到一个最小的没有使用的下标分配给新的文件。



##  重定向原理

![image-20230921135729335](E:\markdown\图片\image-20230921135729335.png)

##  dup2

![image-20230921140102777](E:\markdown\图片\image-20230921140102777.png)

![image-20230921141206426](E:\markdown\图片\image-20230921141206426.png)

参数传递是fd --> 1 使得指针指到同一位置。

##  什么是缓存区，缓冲区本质是什么

缓冲区的本质就是一段内存。

##  为什么要有缓冲区

1.解放使用缓冲区的进程时间

2.缓冲区的存在可以集中处理数据刷新，减少IO的次数，从而答到提高整机的效率的目的。

##  缓冲区原理

![image-20230921215630536](E:\markdown\图片\image-20230921215630536.png)

缓冲区其实是由C语言提供的，不是由系统提供的。

每打开一个文件就有一个缓冲区，打开10个文件就有10个缓冲区。

![image-20230921220503289](E:\markdown\图片\image-20230921220503289.png)

为什么刷新两次？因为fork()之后，父子代码共享，数据会发生写时拷贝。

##  模拟封装C标准库




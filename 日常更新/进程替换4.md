进程替换4

 ##  进程程序替换

![image-20230919201134608](E:\markdown\图片\image-20230919201134608.png)

##  excel接口

![image-20230919202637287](E:\markdown\图片\image-20230919202637287.png)

让main函数执行ls命令，或者执行其他命令。

但是后面的printf代码未执行，因为**一旦替换程序成功，是将当前进程的代码和数据全部替换**了。所以printf的代码已经没了。不会再被执行了。

这个函数不需要返回值。还是因为代码和数据替换了，就不会有return后面的值了。

![image-20230919203535076](E:\markdown\图片\image-20230919203535076.png)

 ##  execv

和excel有什么区别？只有传参的方式不同。

execl的l可以看作是list，

execv可以看做是vector看作是数组。

##  execlp带环境变量的



![image-20230919210237749](E:\markdown\图片\image-20230919210237749.png)

##  execlvp

这个就是在PATH里找程序名。

然后将命令行参数字符串，统一放入数组中

![image-20230919210431517](E:\markdown\图片\image-20230919210431517.png)

##  execle

这个函数多了一个环境变量的参数。

![image-20230919212450982](E:\markdown\图片\image-20230919212450982.png)

##  为什么会有这么多接口，但是只有execve是单独的？

因为execve才是真正意义上的系统接口，上面的所有的接口都是对execve的封装。

![image-20230919213411631](E:\markdown\图片\image-20230919213411631.png)

#  vim注释

![image-20230919205918112](E:\markdown\图片\image-20230919205918112.png)

##  简易版shell

![image-20230919215952493](E:\markdown\图片\image-20230919215952493.png)
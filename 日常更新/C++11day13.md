C++11day13

#  统一的列表初始化

#  主要是支持new[ ]数组

针对数组的初始化

```
int* p1 = new int[3]{1,2,3};
```

比如对日期类的初始化



```
 Date* p2 = new Date[3]{{2023,1,1},{2023,1,1},{2023,1,1}};
```

 再比如

```
vector<Date> v3 = {{2023,1,1},{2023,1,1},{2023,1,1}};
```

 

##  原理(initializer_list) 

这些花括号会被自动识别为initialize_list类型。

![image-20230814165951208](E:\markdown\图片\image-20230814165951208.png)

![image-20230814170214623](E:\markdown\图片\image-20230814170214623.png)

但是正常情况下都不会这么使用。

C++11之后，vector，list等一切容器都增加了initializer_list<value_type> il构造函数。

这是C++11扩展的类似隐士类型的转换。

##  decltype关键字

可以定义变量的类型。

![image-20230814172603028](E:\markdown\图片\image-20230814172603028.png)

##  nullptr改变

![image-20230814172653919](E:\markdown\图片\image-20230814172653919.png)

## array的增加

Array主要是为了解决越界，进行强制检查抛异常，访问更安全。

#  右值引用(提高效率)

##  区分左值和右值

左值是一个数据表达式，左值可以出现在赋值符号的左边，但右值不能出现在赋值符号的左边。

什么是左值？

**1.能够取地址**

**2.能够赋值**

**特例：const修饰的是左值，但是能取地址。**

总结是不是左值，就来判断能不能取地址，和赋值，记住const是意外。

左值引用不能引用右值，但是加了const的修饰，就可以引用右值，涉及权限放大问题。

![image-20230814174805712](E:\markdown\图片\image-20230814174805712.png)

##  什么是右值

  **右值不可以取地址，这是和左值的最大的区别。**

函数传值返回的都是右值，因为他是临时变量。

![image-20230814174001329](E:\markdown\图片\image-20230814174001329.png)

右值不能取地址，但是对右值引用后，这个引用变量可以取地址。

但是实际应用和这个没关系。



右值引用只能引用右值，不能引用左值，但是可以引用move后的左值。

![image-20230814174937955](E:\markdown\图片\image-20230814174937955.png)

## 应用场景

右值引用是为了解决那些只能传值返回，进行拷贝效率低的问题。比如opertaor+,后置++等问题。

![image-20230814180657769](E:\markdown\图片\image-20230814180657769.png)

move也是将亡值。可以把左值改变为右值。  然后进行资源转移

解决步骤

![image-20230814181209881](E:\markdown\图片\image-20230814181209881.png)

1.先增加一个右值引用的构造函数。（这里面的右值也叫做将亡值）

有了右值(移动)构造函数，编译器会走最匹配的，右值走移动，左值走左值构造。

传值返回的时候，会进行编译器的优化，直接一步构造完成资源的转移。

![image-20230814191156219](E:\markdown\图片\image-20230814191156219.png)

##  move

move有可能会把资源转移了。

![image-20230814202757897](E:\markdown\图片\image-20230814202757897.png)

所以尽量用移动构造的语句，传参传右值。

#  万能引用

```C++
template<typename T>
void PerfectForward(T&& t)
{
	Fun(t);
}
```

**模板中的&&不代表右值引用。**

**他的作用仅仅是既能接受左值又能接受右值。这就是他唯一的功能。**

但是后面的 t 全都会退化成左值。！

所以就要用完美转发解决这个问题。

##  完美转发

以下是完美转发的语法，可以把 t 转化为合适的值，是左值就是左值，是右值就转成右值。

```C++
template<typename T>
void PerfectForward(T&& t)
{
	cao::string copy2 = std::forward<T>(t);
}
```

可以保证对将亡值走右值引用，左值还是走左值引用。

 有时候完美转发 也需要套好几层，只要碰到模板。

##  移动构造和移动赋值

这俩构造函数，假如不写编译器会自动生成，但是条件极其苛刻。

# default关键字

default可以强制让他生成 默认构造函数



```
Person(Person&& pp) = default;

Person& operator=(Person&& pp) = default;
```

#  delete关键字

delete可以禁止生成构造函数。

只是把default改为delete就可以了


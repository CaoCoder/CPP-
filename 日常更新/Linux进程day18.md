#  进程

##  为什么要有内存

![image-20230819091227673](E:\markdown\图片\image-20230819091227673.png)

##  为什么程序需要先加载到内存？

因为cpu要执行这个代码，但cpu只和内存交互，但这个代码在磁盘上，所以需要加载到内存。

##  预装载

例如：开机等待就是为了将操作系统提前加载到内存。

局部性原理：比如现在执行第10行代码，然后就能推断下来要执行10行上下的代码。

这样可以提高效率

例如：电脑刚启动很卡，用上几个小时，就不卡了，这就是预装载的效果

##   运算器和控制器

虽然cpu在数据上不和外设交互，但是在控制上是和外设交互的。

中央处理器为什么要计算，这些都是由操作系统控制的。cpu只是被动的完成任务，是一个傀儡。

##  执行流

几乎所有的软件都是先从外设输入数据，输入到内存，然后cpu计算，再把数据输出到外设。

![image-20230819093333422](E:\markdown\图片\image-20230819093333422.png)

##  管理

操作系统是一个管理的软件。**管理的本质是对数据做管理**

![image-20230819093822147](E:\markdown\图片\image-20230819093822147.png)

**对数据的管理，就是对数据结构的管理。**

管理的核心理念：**先描述，再组织。**

也就是先定义结构体，或者类，再通过数据结构进行管理，比如增删查改。



所以对进程的管理，就是对进程数据的管理，所以就是对数据结构的管理。

在Linux中，结构体名称叫做task_struct 这个结构体里面包含了 进程的所有属性数据。

![image-20230819104919993](E:\markdown\图片\image-20230819104919993.png)

把进程的结构体+代码.exe组合起来就是 = 进程

在操作系统中这个PCB = task_struct ,这也叫做进程控制块。

##  操作系统为什么要给我提供服务？

所谓的打印例如cout 和printf没有资格向硬件写入。

 因为上层用户，比如软件等要直接或者间接用到硬件，比如磁盘，网卡，显示器。

##  如何提供服务？

操作系统不相信任何人，他不会暴露自己的任何数据结构。所以提供了系统调用的方式，对外提供服务的。

因为Linux系统是C语言写的，所以所谓的接口，就是C语言函数。

**在系统调用接口上面就是用户操作接口。比如shell外壳，lib，比如std库，部分指令。**

![image-20230819133439927](E:\markdown\图片\image-20230819133439927.png)

##  windows和Linux的系统接口不一样，为什么C/C++调printf都可以用？

这些就是多态，各自有各自的接口。但是上层用的都一样，不用管。



##  查看进程的方案

ps axj | grep +进程名字

ps axj是列出全部进程，然后利用管道，筛选出特定的进程。

##  当前路径

**各种指令都在/ usr / bin / cmd 目录下。**

proc目录里面放的是**进程的实时信息**。

##  进程的pid

![image-20230819141713695](E:\markdown\图片\image-20230819141713695.png)

这些蓝色的数字就叫做进程的pid。

就是进程的唯一标识，相当于你的身份证号。

##  ps axj | head -1
可以把进程头部信息名称显示出来。

```shell
ps axj | head -1
  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND

```

```shell
csq@ubuntu:/$ ps axj | head -1 && ps axj | grep 'test' | grep -v grep
  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND
 34391  35075  35075  34391 pts/18    35075 S+    1000   0:00 ./test

```

##  路径

```shell
csq@ubuntu:/$ ls /proc/35948 -al
lrwxrwxrwx   1 csq  csq  0 8月  19 14:33 cwd -> /home/csq/lesson/day18
-r--------   1 csq  csq  0 8月  19 14:33 environ
lrwxrwxrwx   1 csq  csq  0 8月  19 14:33 exe -> /home/csq/lesson/day18/test

```

   所谓的当前路径就是：**当前进程所在的路径。**

cwd->就是进程所在的路径。也就是当前路径。

##  pid和当前路径都在哪里？

这些都是进程的内部属性。所以都在进程的进程控制块中PCB(task_struct)结构体当中。

##  获取进程的pid

![image-20230819144254751](E:\markdown\图片\image-20230819144254751.png)

kill -9 +进程pid 就是给这个进程发送9号信号进行杀掉进程。

## 父进程

父进程的pid就是bash的pid。

##  fork

![image-20230819152822437](E:\markdown\图片\image-20230819152822437.png)

![image-20230819154407545](E:\markdown\图片\image-20230819154407545.png)

虽然代码共享，但是数据要各自独立。

​                 

##  进程的状态


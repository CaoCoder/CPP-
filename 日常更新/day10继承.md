day10继承



#  继承 

子类对象可以给给父类 的对象/指针/引用  这些是天然形成的，不会在中间产生临时对象。



```C++
#include <iostream>
using namespace std;
class Person
{
public:
// protected:
    string _name;
    string _sex;
    int _age;
    
};

class Student:public Person
{
public:
    int _No;//学号
    
};

int main()
{
    Person p;
    Student s;
    
    s._name = "张三";
    s._age = 18;
    s._sex = "男";


    p = s;
    Person& rp = s;
    Person* pp = &s;
}
```

rp可以理解为是派生类中属于父类那一部分的别名。**(在调用父类的拷贝构造是传参能体现出来)**

pp也可以理解为是指向子类中属于父类的那一部分。

##  隐藏

假如子类和父类有同名成员的变量。那么子类访问这个变量的话会构成隐藏，也就是先访问子类的。也叫做(重定义)。

假如真的想访问父类的这个变量，需要指定一下类域，在变量名前加上父类的域。

但一般都不会设计同名的。

  

同名函数也一样、也是指定作用域就可以访问。

**和重载有时候会迷惑。** **记住重载要求在同一作用域**

 

#  派生类的构造成员函数

子类构造函数的原则：

1.先调用父类的构造函数初始化继承自父类的成员

2.自己再初始化自己的成员

析构，拷贝构造，赋值重载函数也类似。

![image-20230811145854731](E:\markdown\图片\image-20230811145854731.png)

初始化列表是按照声明的顺序初始化的，因为父类肯定是在子类的前面声明的，所以无论父类是写在后面还是前面，都是先初始化父类。

子类自己的成员还是像普通类一样初始化。只是父类用的是类名+需要初始化的变量。

##  隐藏的案例

  ![image-20230811150736495](E:\markdown\图片\image-20230811150736495.png)

这里的operator=在子类和父类当中涉及到了隐藏。所以需要显示调用父类的operator=。负责会导致栈溢出，也就是在函数中死循环调用。

##  析构函数构成隐藏

父子类的析构函数构成隐藏关系。为什么他们会构成隐藏呢？名字不一样。

**一个是~Person一个是~Student，这又是为什么。**

**原因：下一节多态的需要，析构函数名统一会被处理成destructor()**

![image-20230811151628991](E:\markdown\图片\image-20230811151628991.png)

**为了保证析构的时候先子后父，所以不需要显示调用父类的析构函数。**

系统会在子类析构后自动调用父类的析构函数。

​    

#  多继承

多继承可能会导致菱形继承，然后会出现数据二义性，和数据冗余的问题。

这是多继承的对象模型，谁先继承先初始化谁。

![image-20230811164329345](E:\markdown\图片\image-20230811164329345.png)

解决方法就是用虚继承，在菱形继承的腰部位置加上virtual

#  虚继承

以下是加了virtual的对象模型图

![image-20230811164906321](E:\markdown\图片\image-20230811164906321.png)

![image-20230811171748560](E:\markdown\图片\image-20230811171748560.png)

通过偏移量来计算A的位置。A叫做虚基类。

这个表也叫做虚基表

![image-20230811173913483](E:\markdown\图片\image-20230811173913483.png)

不管这个指针指向B还是D，都是以同样的方式找A成员，先找到虚基表中的偏移量，然后计算A的位置。

C++IO流使用了菱形继承。

#  继承和组合

继承就是用继承语法。

组合是has-a的关系，每个组合对象B都有一个A对象。

![image-20230811182317519](E:\markdown\图片\image-20230811182317519.png)

优先使用组合，而不是继承。

继承是一种白箱复用，那么这个权限更大，基类的细节是可见的。继承在一定程度上破坏了封装。

组合是一种黑箱复用，对于保护成员不能直接用。

#   多态

 比如不同的手机用户，点外卖的，打车钱不一样。不一定是用多态来实现的，但是可以用多态来实现。

##  重写/覆盖

条件：虚函数+函数名，参数，返回值，相同则构成重写和覆盖。


##  程序地址空间(进程地址空间)

##  bash

命令行中启动的进程，父进程全都是bash

对于echo和export来说，两个都是子进程，但是子进程不继承环境变量，那么怎么能显示出来环境变量呢？

![image-20230917190621050](E:\markdown\图片\image-20230917190621050.png)

##  环境变量具有全局属性

 环境变量是会被子进程继承下去的。就像一颗树，会一直继承。

所谓的本地变量，本质就是bash内部定义的变量，不会被继承。

##  进程地址空间

![image-20230917193041424](E:\markdown\图片\image-20230917193041424.png)

堆是向上增长，栈是向下增长。

所以说C语言定义的变量的地址一般是较大的，然后依次减小。



**每一个进程都会有自己的进程地址空间。**

进程地址空间是内核的一个数据结构。struct mm_struct

地址空间存在的最大意义就是：**让每一个进程都认为自己是独占系统中的所有资源的，也就是内存。**



![image-20230917211403271](E:\markdown\图片\image-20230917211403271.png)

每个PCB里面有个指针，指向进程地址空间。

![image-20230917211748556](E:\markdown\图片\image-20230917211748556.png)

**页表：将程序加载到内存，变为进程后，操作系统会给每一个进程构建一个页表结构。**



##  如何理解static的变量

![image-20230917193637729](E:\markdown\图片\image-20230917193637729.png)

##  同一个地址，不同的值

说明这不是物理地址，是虚拟地址。

![image-20230917214215930](E:\markdown\图片\image-20230917214215930.png)父子进程，虚拟地址同时映射到一个物理内存。



当子进程需要修改时，物理内存会开辟拷贝一份空间。

然后修改页表对物理内存的指向

![image-20230917214500644](E:\markdown\图片\image-20230917214500644.png)

![image-20230917214728869](E:\markdown\图片\image-20230917214728869.png)

##  程序没有加载到内存的时候也是有地址的。

![image-20230917212812470](E:\markdown\图片\image-20230917212812470.png)

由于需要链接，所以存在地址。加载到内存的时候，在虚拟地址空间通过逻辑地址，进行地址相加转化为虚拟地址。

然后根据这个虚拟地址，通过页表进行映射到进程虚拟地址空间。

![image-20230917213139274](E:\markdown\图片\image-20230917213139274.png)

![image-20230917213627551](E:\markdown\图片\image-20230917213627551.png)

 

可以拿学生排队进教室坐座位的例子来举例。

<img src="E:\markdown\图片\image-20230917213810059.png" alt="image-20230917213810059" style="zoom:67%;" />

![image-20230917214126137](E:\markdown\图片\image-20230917214126137.png

##  fork()有两个返回值，同一个变量有不同的值。

![image-20230917214937264](E:\markdown\图片\image-20230917214937264.png)

##   虚拟地址空间是什么？

简单来说就是老师点名，学生答到，就能找到学生。

##  为什么要有虚拟地址空间

1.保护内存

2.将进程管理 和 Linux内存管理通过 页 表 进行解耦

3.让进程可以以一种统一的视角看待内存。方便以统一的方式来编译和加载所有可执行程序。

